var questions = [
    {
        id: "43616EC3-7454-4440-8AB3-8DF093AB72E4",
        name: "Qual ser\u00E1 a saida ?",
        code: "\n    function sayHi() {\n      console.log(name);\n      console.log(age);\n      var name = \"Person\";\n      let age = 21;\n    }\n    \n    sayHi();\n    ",
        answerPosition: 3,
        options: [
            "Person e undefined",
            "Person e ReferenceError",
            "ReferenceError e 21",
            "undefined e ReferenceError",
        ],
        explanation: "\n      Dentro da fun\u00E7\u00E3o, n\u00F3s primeiro declaramos a vari\u00E1vel name usando a palavra-chave var. Isso significa que a vari\u00E1vel \u00E9\n      elevada(hoisted) (O espa\u00E7o na mem\u00F3ria \u00E9 separado durante a fase de cria\u00E7\u00E3o) com o valor padr\u00E3o undefined, at\u00E9 que \n      chegue na linha onde definimos a vari\u00E1vel. Ainda n\u00E3o definimos a vari\u00E1vel na linha onde tentamos usar colocar no log\n      o valor da vari\u00E1vel name, portanto ela ainda tem o valor undefined.\n\n      Vari\u00E1veis com a palavra-chave let (e const) s\u00E3o elevadas, mas diferente de var, n\u00E3o s\u00E3o inicializadas. Elas n\u00E3o est\u00E3o acess\u00EDveis\n      antes da linha em que as declaramos (ou inicializamos). Esse \u00E9 um conceito chamado de \"temporal dead zone\". Quando tentamos acessar\n      essas vari\u00E1veis antes de serem declaradas, o JavaScript lan\u00E7a um ReferenceError.\n      ",
    },
    {
        id: "98D9A410-BD6E-45A2-AED9-7C3ECA43F3EB",
        name: "Qual será a saída?",
        code: "\n    for (var i = 0; i < 3; i++) {\n      setTimeout(() => console.log(i), 1);\n    }\n    \n    for (let i = 0; i < 3; i++) {\n      setTimeout(() => console.log(i), 1);\n    }\n    ",
        answerPosition: 2,
        options: [
            "0 1 2 e 0 1 2",
            "0 1 2 e 3 3 3",
            "3 3 3 e 0 1 2",
            "1 2 3 e 0 1 2",
        ],
        explanation: "\n      \"'This' palavra-chave \u00E9 usada para se referir ao objeto atrav\u00E9s do qual as propriedades\n       ou m\u00E9todos foram invocados. Este uso de 'this' \u00E9 uma caracter\u00EDstica fundamental dos m\u00E9todos de qualquer classe.\",\n      ",
    },
    {
        id: "6DB5C7C0-20B9-427B-9BC0-881143843368",
        name: "Qual será a saída?",
        code: "\n    const shape = {\n      radius: 10,\n      diameter() {\n        return this.radius * 2;\n      },\n      perimeter: () => 2 * Math.PI * this.radius\n    };\n    \n    shape.diameter();\n    shape.perimeter();\n    ",
        options: ["20 e 62.83185307179586", "20 e NaN", "20 e 63", "NaN e 63"],
        answerPosition: 1,
        explanation: "\n      Perceba que o valor de diameter \u00E9 uma fun\u00E7\u00E3o normal, enquanto que o valor de perimeter \u00E9 uma arrow function.\n      Com arrow functions, a palavra-chave this faz refer\u00EAncia ao escopo atual em que est\u00E1 inserida, diferente de fun\u00E7\u00F5es normais!\n      Isso significa que quando n\u00F3s chamamos perimeter, ela n\u00E3o faz refer\u00EAncia ao objeto shape, mas ao seu escopo atual (por exemplo, window).\n      N\u00E3o h\u00E1 radius fora de shape, ent\u00E3o retorna undefined.\n      ",
    },
    {
        id: "1507B8E8-65FF-4785-987F-0906271EF061",
        name: "Qual será a saída?",
        code: "\n    +true;\n    !\"User\";\n    ",
        answerPosition: 0,
        options: ["1 e false", "false e NaN", "false e false", "true e true"],
        explanation: "\n      O operador un\u00E1rio + tenta converter um operando para um n\u00FAmero. true \u00E9 1, e false \u00E9 0.\n      A string 'User' tem valor truthy*. O que estamos realmente perguntando \u00E9 \"Esse valor truthy \u00E9 falsy?\". Isso retorna false.\n      ",
    },
    {
        id: "4F0560FD-768F-4779-9AE5-27EC55EE2206",
        name: "Qual será a saída?",
        code: "\n    const bird = {\n      size: \"small\"\n    };\n    \n    const mouse = {\n      name: \"Mickey\",\n      small: true\n    };\n    ",
        answerPosition: 0,
        options: [
            "mouse.bird.size não é válido",
            "mouse[bird.size] não é válido",
            "mouse[bird['size']] não é válido",
            "Todos são válidos",
        ],
        explanation: "\n      No JavaScript, todas chaves dos objetos s\u00E3o strings (a n\u00E3o ser que sejam um s\u00EDmbolo). Ainda que n\u00E3o possamos digit\u00E1-las\n      como strings, elas s\u00E3o sempre convertidas para string sob o cap\u00F4.\n      JavaScript interpreta afirma\u00E7\u00F5es. Quando usamos a nota\u00E7\u00E3o de colchetes, ele v\u00EA o colchete de abertura [ e continua lendo\n      at\u00E9 encontrar o colchete que o fecha ]. S\u00F3 ent\u00E3o vai avaliar e rodar as afirma\u00E7\u00F5es.\n      mouse[bird.size]: Primeiro avalia bird.size, que \u00E9 \"small\". mouse[\"small\"] retorna true\n      Por outro lado, com a nota\u00E7\u00E3o de ponto ., isso n\u00E3o acontece. mouse n\u00E3o tem uma chave chamada bird, o que significa que mouse.bird \n      \u00E9 undefined. Ent\u00E3o, pedimos pelo size usando a nota\u00E7\u00E3o de ponto: mouse.bird.size. Uma vez que mouse.bird \u00E9 undefined, estamos realmente pedindo undefined.size. Isso n\u00E3o \u00E9 v\u00E1lido, e ir\u00E1 gerar um erro similar a Cannot read property \"size\" of undefined.\n      ",
    },
    {
        id: "15ADBDCE-1F18-4C7A-A8A3-2E1FEC6D5311",
        name: "Qual será a saída?",
        code: "\n    let c = { greeting: \"Hey!\" };\n    let d;\n    \n    d = c;\n    c.greeting = \"Hello\";\n    console.log(d.greeting);\n    ",
        answerPosition: 0,
        options: ["Hello", "Hey", "undefined", "ReferenceError"],
        explanation: "\n      Em JavaScript, todos objetos interagem por refer\u00EAncia quando os colocamos um igual ao outro.\n      Primeiro, a vari\u00E1vel c guarda o valor de um objeto. Depois, declaramos d com a mesma referencia que c tem para o objeto.\n      ",
    },
    {
        id: "C35F4860-0781-4B9F-B951-C8FA6ED2C3AC",
        name: "Qual será a saída?",
        code: "\n    let a = 3;\n    let b = new Number(3);\n    let c = 3;\n    \n    console.log(a == b);\n    console.log(a === b);\n    console.log(b === c);\n    ",
        answerPosition: 2,
        options: [
            "true false true",
            "false false true",
            "true false false",
            "false true true",
        ],
        explanation: "\n      new Number() \u00E9 uma fun\u00E7\u00E3o construtura padr\u00E3o do JavaScript. Ainda que parece com um n\u00FAmero, n\u00E3o \u00E9 realmente um n\u00FAmero: Tem um monte de fun\u00E7\u00F5es extras e \u00E9 um objeto.\n      Quando usamos o operador ==, s\u00F3 conferimos se ambas tem o mesmo valor. Ambas tem o valor de 3, ent\u00E3o retorna true.\n      Contudo, quando usamos o operador ===, ambos valor e tipo tem de ser o mesmo. E n\u00E3o s\u00E3o: new Number() n\u00E3o \u00E9 um n\u00FAmero, \u00E9 um objeto. Ambos retornam false.\n      ",
    },
    {
        id: "422A325A-D034-453F-A071-559C1377D555",
        name: "Qual será a saída?",
        code: "\n    class Chameleon {\n      static colorChange(newColor) {\n        this.newColor = newColor;\n        return this.newColor;\n      }\n    \n      constructor({ newColor = \"green\" } = {}) {\n        this.newColor = newColor;\n      }\n    }\n    \n    const freddie = new Chameleon({ newColor: \"purple\" });\n    freddie.colorChange(\"orange\");\n    ",
        options: ["orange", "purple", "green", "TypeError"],
        answerPosition: 3,
        explanation: "\n    A fun\u00E7\u00E3o colorChange \u00E9 est\u00E1tica. M\u00E9todos est\u00E1ticos s\u00E3o designados para viver somente nos construtores em que s\u00E3o criados,\n    e filhos n\u00E3o herdam esses m\u00E9todos. J\u00E1 que freddie \u00E9 filho de Chameleon, a fun\u00E7\u00E3o n\u00E3o \u00E9 herdada, e n\u00E3o est\u00E1 dispon\u00EDvel para freddie: \n    Um erro TypeError \u00E9 gerado.\n    ",
    },
    {
        id: "4FF53449-4F74-4AC2-8C07-C7BCADB30CF9",
        name: "Qual será a saída?",
        code: "\n    let greeting;\n    greetign = {}; // Erro de digita\u00E7\u00E3o!\n    console.log(greetign); \n    ",
        answerPosition: 0,
        options: [
            "{}",
            "ReferenceError: greetign is not defined",
            "undefined",
            "0",
        ],
        explanation: "\n    Cria o log do objeto, pois criamos um objeto vazio no objeto global! Quando erramos a digita\u00E7\u00E3o de greeting como greetign,\n    o interpretador do JavaScript viu isso como global.greetign = {} (ou window.greetign = {} em um navegador).\n    Para evitar esse comportamento, podemos usar \"use strict\". Isso garante que voc\u00EA tenha declarado uma vari\u00E1vel\n    antes de poder inicializ\u00E1-la com algum valor.\n    ",
    },
    {
        id: "B1AB38B9-4B2C-4897-91CF-701297B60C97",
        name: "Qual será a saída?",
        code: "\n    function bark() {\n      console.log(\"Woof!\");\n    }\n    \n    bark.animal = \"dog\";\n    ",
        options: [
            "Nada, isso é ok!",
            "SyntaxError. Não se pode adicionar propriedades em uma função dessa maneira.",
            "undefined",
            "ReferenceError",
        ],
        answerPosition: 0,
        explanation: "\n    Isso \u00E9 poss\u00EDvel em JavaScript, pois fun\u00E7\u00F5es s\u00E3o objetos! (Tudo menos tipos primitivos s\u00E3o objetos)\n    Uma fun\u00E7\u00E3o \u00E9 um tipo especial de objeto. O c\u00F3digo que voc\u00EA escreve n\u00E3o \u00E9 a verdadeira fun\u00E7\u00E3o. \n    A fun\u00E7\u00E3o \u00E9 um objeto com propriedades. E essa propriedade \u00E9 invoc\u00E1vel.\n    ",
    },
    {
        id: "5C4694EC-8FDF-4902-BC50-8A081AEC4C54",
        name: "Qual será a saída?",
        code: "\n    function Person(firstName, lastName) {\n      this.firstName = firstName;\n      this.lastName = lastName;\n    }\n    \n    const member = new Person(\"Lydia\", \"Hallie\");\n    Person.getFullName = function() {\n" +
            "       return ${this.firstName} ${this.lastName};\n" +
            "    };\n    \n    console.log(member.getFullName());\n    ",
        answerPosition: 0,
        options: [
            "TypeError",
            "SyntaxError",
            "Lydia Hallie",
            "undefined undefined",
        ],
        explanation: "",
    },
    {
        id: "75BC8885-833A-422B-94F4-379CD23DEBBB",
        name: "Qual será a saída?",
        code: "\n    function Person(firstName, lastName) {\n      this.firstName = firstName;\n      this.lastName = lastName;\n    }\n    \n    const lydia = new Person(\"Lydia\", \"Hallie\");\n    const sarah = Person(\"Sarah\", \"Smith\");\n    \n    console.log(lydia);\n    console.log(sarah);\n    ",
        answerPosition: 0,
        options: [
            "Person {firstName: 'Lydia', lastName: 'Hallie'} e undefined",
            "Person {firstName: 'Lydia', lastName: 'Hallie'} e Person {firstName: 'Sarah', lastName: 'Smith'}",
            "Person {firstName: 'Lydia', lastName: 'Hallie'} e {}",
            "Person {firstName: 'Lydia', lastName: 'Hallie'} e ReferenceError",
        ],
        explanation: "",
    },
];
//# sourceMappingURL=questions.js.map